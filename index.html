<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      background: radial-gradient(circle at center, #0f0f0f 0%, #1a1a1a 100%);
      color: white;
    }

    canvas {
      display: block;
    }

    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 18px;
      box-shadow: 0 0 12px #00ff99;
      border: 1px solid #00ff99;
    }

    #comboDisplay {
      position: absolute;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 2em;
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }

    #game-over {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: red;
      display: none;
      text-align: center;
    }

    #game-over button {
      margin-top: 10px;
      font-size: 1em;
      padding: 10px 20px;
      background: lime;
      border: none;
      color: black;
      cursor: pointer;
    }
  </style>
</head>
<body>
<div id="ui">
  <div>ðŸŽ¯ Score: <span id="score">0</span></div>
  <div>ðŸš€ Level: <span id="level">1</span></div>
  <div>âš¡ WPM: <span id="wpm">0</span></div>
</div>
<div id="comboDisplay"></div>
<canvas id="gameCanvas"></canvas>
<div id="game-over">ðŸ’€ Game Over<br><button onclick="location.reload()">Restart</button></div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const wordList = ['fire', 'ice', 'storm', 'rune', 'portal', 'spell', 'magic', 'dark', 'light', 'burn', 'time', 'zap', 'chaos', 'nova'];
let activeWords = [];
let projectiles = [];
let currentWord = null;
let typedIndex = 0;
let gameOver = false;
let score = 0;
let level = 1;
let playerHP = 100;
let enemyHP = 100;
let wordSpeedBase = 2;
let combo = 0;
let wordsTyped = 0;
let startTime = Date.now();
let bgOffset = 0;
let enemyFlashTimer = 0;

// Star background
let stars = [];
for (let i = 0; i < 100; i++) {
  stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2 });
}

class Word {
  constructor(text, x, y, speed) {
    this.text = text;
    this.x = x;
    this.y = y;
    this.speed = speed;
  }

  draw() {
    ctx.fillStyle = 'white';
    ctx.font = '26px monospace';
    ctx.fillText(this.text, this.x, this.y);
    if (currentWord === this) {
      ctx.fillStyle = 'cyan';
      ctx.fillText(this.text.substring(0, typedIndex), this.x, this.y);
    }
  }

  update() {
    this.x -= this.speed;
    if (this.x <= 80) {
      activeWords = activeWords.filter(w => w !== this);
      playerHP -= 10 + level; // Increased damage as level rises
      combo = 0;
      updateComboDisplay();
      if (playerHP <= 0) endGame();
    }
  }
}

class Projectile {
  constructor(x, y, color) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.speed = 25;
    this.radius = 6;
  }

  update() {
    this.x += this.speed;
  }

  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = this.color;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 15;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

function spawnWord() {
  const text = wordList[Math.floor(Math.random() * wordList.length)];
  const y = canvas.height - 120;
  const x = canvas.width - 80;
  const speed = wordSpeedBase + Math.random() * 0.5;
  activeWords.push(new Word(text, x, y, speed));
}
setInterval(spawnWord, 2000);

function drawHealthBar(x, y, width, height, value, color, label) {
  ctx.fillStyle = 'gray';
  ctx.fillRect(x, y, width, height);
  ctx.fillStyle = color;
  ctx.fillRect(x, y, Math.max(0, value), height);
  ctx.fillStyle = 'white';
  ctx.font = '12px monospace';
  ctx.fillText(label, x, y - 4);
}

function updateComboDisplay() {
  const comboDisplay = document.getElementById('comboDisplay');
  if (combo > 0) {
    comboDisplay.innerText = `ðŸ”¥ Combo x${combo}`;
    comboDisplay.style.opacity = 1;
    setTimeout(() => {
      comboDisplay.style.opacity = 0;
    }, 1000);
  }
}

function updateWPM() {
  const elapsed = (Date.now() - startTime) / 60000;
  const wpm = Math.round(wordsTyped / elapsed);
  document.getElementById('wpm').innerText = wpm;
}

function drawStars() {
  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'white';
  for (let s of stars) {
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
    s.x -= 0.5;
    if (s.x < 0) s.x = canvas.width;
  }
}

function gameLoop() {
  if (gameOver) return;

  drawStars();

  // Scrolling ground like Dino game
  bgOffset -= 4;
  if (bgOffset <= -40) bgOffset = 0;
  for (let i = 0; i < canvas.width / 40 + 2; i++) {
    ctx.fillStyle = '#333';
    ctx.fillRect(bgOffset + i * 40, canvas.height - 40, 40, 40);
  }

  // Enemy
  ctx.fillStyle = enemyFlashTimer > 0 ? 'white' : 'red';
  ctx.fillRect(canvas.width - 80, canvas.height - 160, 60, 60);
  drawHealthBar(canvas.width - 140, canvas.height - 180, 100, 10, enemyHP, 'red', 'ENEMY');
  if (enemyFlashTimer > 0) enemyFlashTimer--;

  // Player
  ctx.fillStyle = 'lime';
  ctx.fillRect(20, canvas.height - 160, 60, 60);
  drawHealthBar(20, canvas.height - 180, 100, 10, playerHP, 'lime', 'YOU');

  activeWords.forEach(word => {
    word.update();
    word.draw();
  });

  projectiles.forEach(p => {
    p.update();
    p.draw();
  });

  projectiles = projectiles.filter(p => p.x < canvas.width);
  updateWPM();

  requestAnimationFrame(gameLoop);
}

function levelUp() {
  level++;
  wordSpeedBase += 0.5;
  enemyHP = 100 + level * 5; // Stronger enemy
  document.getElementById('level').innerText = level;
}

function endGame() {
  gameOver = true;
  document.getElementById('game-over').style.display = 'block';
}

window.addEventListener('keydown', e => {
  if (gameOver) return;
  const key = e.key;
  if (!currentWord) {
    for (let word of activeWords) {
      if (word.text[0] === key) {
        currentWord = word;
        typedIndex = 1;
        return;
      }
    }
  } else if (currentWord.text[typedIndex] === key) {
    typedIndex++;
    const color = `hsl(${Math.random() * 360}, 100%, 50%)`;
    projectiles.push(new Projectile(80, canvas.height - 130, color));

    if (typedIndex >= currentWord.text.length) {
      activeWords = activeWords.filter(w => w !== currentWord);
      combo++;
      updateComboDisplay();
      wordsTyped++;
      let points = 1 + combo - 1;
      score += points;
      document.getElementById('score').innerText = score;
      enemyHP -= 10 + level;
      enemyFlashTimer = 5;

      if (enemyHP <= 0) levelUp();
      currentWord = null;
      typedIndex = 0;
    }
  }
});

gameLoop();
</script>
</body>
</html>
