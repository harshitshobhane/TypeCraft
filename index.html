<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Typing Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      background: radial-gradient(circle at center, #0f0f0f 0%, #1a1a1a 100%);
      color: white;
      width: 100%;
      height: 100%;
      overflow-x: hidden;
    }

    canvas {
      display: block;
    }

    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 22px;
      box-shadow: 0 0 12px #00ff99;
      border: 1px solid #00ff99;
    }

    #comboDisplay {
      position: absolute;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 3em;
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }

    #game-over {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: red;
      display: none;
      text-align: center;
    }

    #game-over button {
      margin-top: 20px;
      font-size: 1.2em;
      padding: 15px 30px;
      background: lime;
      border: none;
      color: black;
      cursor: pointer;
    }

    #powerupInfoBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: #ffcc00;
      color: black;
      border: none;
      padding: 10px 15px;
      font-size: 1em;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 0 10px #ffcc00;
    }

    #powerupInfoBox {
      display: none;
      position: absolute;
      top: 70px;
      right: 20px;
      background: #111;
      padding: 15px;
      border: 1px solid #ffcc00;
      color: #ffcc00;
      width: 250px;
      font-size: 14px;
      border-radius: 10px;
      box-shadow: 0 0 10px #ffcc00;
    }
  </style>
</head>
<body>
<div id="ui">
  <div>ðŸŽ¯ Score: <span id="score">0</span></div>
  <div>ðŸš€ Level: <span id="level">1</span></div>
  <div>âš¡ WPM: <span id="wpm">0</span></div>
</div>
<button id="powerupInfoBtn">ðŸ’¡ Power-Up Info</button>
<div id="powerupInfoBox">âš¡ Power-Up Info:<br>
  - ðŸ’› Yellow Word: Heals 20 HP instantly.<br>
  - Appear Chance: ~20%<br>
  - Earn more power-ups by achieving high combos!<br>
  <br>
  ðŸ”¥ Tip: Combo x5 or higher increases healing word chance!
  </div>
<div id="comboDisplay"></div>
<canvas id="gameCanvas"></canvas>
<div id="game-over">ðŸ’€ Game Over<br><button onclick="location.reload()">Restart</button></div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const wordList = ['fire', 'ice', 'storm', 'rune', 'portal', 'spell', 'magic', 'dark', 'light', 'burn', 'time', 'zap', 'chaos', 'nova'];
// Load your custom background
const bgImage = new Image();
bgImage.src = 'background.png';
const characterImg = new Image();
characterImg.src = 'character.png';
const enemyImg = new Image();
enemyImg.src   = 'character2.png';
const slashImg = new Image();
slashImg.src   = 'slash.png';


let activeWords = [];
let projectiles = [];
let powerups = [];
let currentWord = null;
let typedIndex = 0;
let gameOver = false;
let score = 0;
let level = 1;
let playerHP = 100;
let enemyHP = 100;
let wordSpeedBase = 2;
let combo = 0;
let wordsTyped = 0;
let startTime = Date.now();
let bgOffset = 0;
let enemyFlashTimer = 0;

let stars = [];
for (let i = 0; i < 100; i++) {
  stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2 });
}




class Word {
  constructor(text, x, y, speed, isHealing = false) {
    this.text = text;
    this.x = x;
    this.y = y;
    this.speed = speed;
    this.isHealing = isHealing;
  }
 draw() {
  ctx.fillStyle = this.isHealing ? 'yellow' : 'white';
  ctx.font = '26px monospace';
  ctx.fillText(this.text, this.x, this.y);
  if (currentWord === this) {
    ctx.fillStyle = this.isHealing ? '#ffff66' : 'cyan';
    ctx.shadowColor = this.isHealing ? '#ffff66' : 'cyan';
    ctx.shadowBlur = 10;
    ctx.fillText(this.text.substring(0, typedIndex), this.x, this.y);
    ctx.shadowBlur = 0;
  }
}

  update() {
    this.x -= this.speed;
    if (this.x <= 80) {
      activeWords = activeWords.filter(w => w !== this);
      playerHP -= 10 + level;
      combo = 0;
      updateComboDisplay();
      if (playerHP <= 0) endGame();
    }
  }
}


class Projectile {
      constructor(x, y, img, w, h, damage) {
        this.x      = x; this.y = y;
        this.img    = img;
        this.w      = w; this.h = h;
        this.speed  = 25;
        this.damage = damage;
        this.hit    = false;
      }
      update() {
        this.x += this.speed;
        if (!this.hit && this.x >= canvas.width - 80) {
          this.hit = true;
          enemyFlashTimer = 5;
          enemyHP -= this.damage;
          if (enemyHP <= 0) levelUp();
        }
      }
      draw() {
        ctx.drawImage(this.img, this.x, this.y, this.w, this.h);
      }
    }


function spawnWord() {
  const text = wordList[Math.floor(Math.random() * wordList.length)];
  const y = canvas.height - 120;
  const x = canvas.width - 80;
  const speed = wordSpeedBase + Math.random() * 0.5;
  const isHealing = Math.random() < 0.2; // 20% chance to be a healing word
  activeWords.push(new Word(text, x, y, speed, isHealing));
}

setInterval(spawnWord, 2000);

function drawHealthBar(x, y, width, height, value, color, label) {
  ctx.fillStyle = 'gray';
  ctx.fillRect(x, y, width, height);
  ctx.fillStyle = color;
  ctx.fillRect(x, y, Math.max(0, value), height);
  ctx.fillStyle = 'white';
  ctx.font = '12px monospace';
  ctx.fillText(label, x, y - 4);
}

function updateComboDisplay() {
  const comboDisplay = document.getElementById('comboDisplay');
  if (combo > 0) {
    comboDisplay.innerText = `ðŸ”¥ Combo x${combo}`;
    comboDisplay.style.opacity = 1;
    setTimeout(() => {
      comboDisplay.style.opacity = 0;
    }, 1000);
  }
}

function updateWPM() {
  const elapsed = (Date.now() - startTime) / 60000;
  const wpm = Math.round(wordsTyped / elapsed);
  document.getElementById('wpm').innerText = wpm;
}


function gameLoop() {
  if (gameOver) return;

  // 1) background
  ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);

  // 2) ground tiles (if you still want them)
  bgOffset -= 4;
  if (bgOffset <= -40) bgOffset = 0;
  for (let i = 0; i < canvas.width / 40 + 2; i++) {
    ctx.fillStyle = '#333';
    ctx.fillRect(bgOffset + i * 40, canvas.height - 0, 40, 40);
  }

  // 3) enemy sprite + flash
  if (enemyFlashTimer > 0) {
    ctx.globalAlpha = 0.7;
    ctx.drawImage(enemyImg, canvas.width - 250, canvas.height - 319, 265, 300);
    ctx.globalAlpha = 1;
    enemyFlashTimer--;
  } else {
    ctx.drawImage(enemyImg, canvas.width - 250, canvas.height - 319, 265, 300);
  }
  drawHealthBar(
    canvas.width - 140,
    canvas.height - 180,
    100, 10,
    enemyHP, 'red', 'ENEMY'
  );

  // 4) player sprite + health
  ctx.drawImage(characterImg, 20, canvas.height - 319, 255, 300);
  drawHealthBar(20, canvas.height - 180, 100, 10, playerHP, 'lime', 'YOU');

  // 5) words
  activeWords.forEach(w => { w.update(); w.draw(); });

  // 6) power-ups
  powerups.forEach(p => { p.update(); p.draw(); });
  powerups = powerups.filter(p => !p.collected);

  // 7) projectiles (slashes)
  projectiles.forEach(p => { p.update(); p.draw(); });
  projectiles = projectiles.filter(p => !p.hit && p.x < canvas.width);

  // 8) UI
  updateWPM();
  requestAnimationFrame(gameLoop);
}

function levelUp() {
  level++;
  wordSpeedBase += 0.5;
  enemyHP = 100 + level * 5;
  document.getElementById('level').innerText = level;
}

function endGame() {
  gameOver = true;
  document.getElementById('game-over').style.display = 'block';
}

document.getElementById('powerupInfoBtn').addEventListener('click', () => {
  const infoBox = document.getElementById('powerupInfoBox');
  infoBox.style.display = infoBox.style.display === 'none' ? 'block' : 'none';
});

window.addEventListener('keydown', e => {
      if (gameOver) return;
      const key = e.key;
      if (!currentWord) {
        for (let w of activeWords) {
          if (w.text[0] === key) {
            currentWord = w;
            typedIndex = 1;
            return;
          }
        }
      } else if (currentWord.text[typedIndex] === key) {
        typedIndex++;
        if (typedIndex >= currentWord.text.length) {
          // word done
          activeWords = activeWords.filter(w => w !== currentWord);
          combo++; updateComboDisplay();
          wordsTyped++;
          score += 1 + combo - 1;
          document.getElementById('score').innerText = score;

          if (currentWord.isHealing) {
            playerHP = Math.min(100, playerHP + 20);
          } else {
            // SPAWN SLASH
            projectiles.push(
              new Projectile(
                80,
                canvas.height - 230,
                slashImg,
                255, 160,
                10 + level
              )
            );
          }

          currentWord = null;
          typedIndex   = 0;
        }
      } else {
        combo = 0; updateComboDisplay();
        currentWord = null; typedIndex = 0;
      }
    });
gameLoop();
</script>
</body>
</html>