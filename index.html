<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Typing Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: 'Courier New', monospace;
      background: radial-gradient(circle at center, #0f0f0f 0%, #1a1a1a 100%);
      color: white;
      width: 100%;
      height: 100%;
      overflow-x: hidden;
    }

    canvas {
      display: block;
    }

    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 22px;
      box-shadow: 0 0 12px #00ff99;
      border: 1px solid #00ff99;
    }

    #comboDisplay {
      position: absolute;
      top: 100px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 3em;
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
    }

    #game-over {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: red;
      display: none;
      text-align: center;
    }

    #game-over button {
      margin-top: 20px;
      font-size: 1.2em;
      padding: 15px 30px;
      background: lime;
      border: none;
      color: black;
      cursor: pointer;
    }

    #powerupInfoBtn {
      position: absolute;
      top: 20px;
      right: 20px;
      background: #ffcc00;
      color: black;
      border: none;
      padding: 10px 15px;
      font-size: 1em;
      border-radius: 8px;
      cursor: pointer;
      box-shadow: 0 0 10px #ffcc00;
    }

    #powerupInfoBox {
      display: none;
      position: absolute;
      top: 70px;
      right: 20px;
      background: #111;
      padding: 15px;
      border: 1px solid #ffcc00;
      color: #ffcc00;
      width: 250px;
      font-size: 14px;
      border-radius: 10px;
      box-shadow: 0 0 10px #ffcc00;
    }
  </style>
</head>
<body>
<div id="ui">
  <div>ðŸŽ¯ Score: <span id="score">0</span></div>
  <div>ðŸš€ Level: <span id="level">1</span></div>
  <div>âš¡ WPM: <span id="wpm">0</span></div>
</div>
<button id="powerupInfoBtn">ðŸ’¡ Power-Up Info</button>
<div id="powerupInfoBox">âš¡ Power-Up Info:<br>
  - ðŸ’› Yellow Word: Heals 20 HP instantly.<br>
  - Appear Chance: ~20%<br>
  - Earn more power-ups by achieving high combos!<br>
  <br>
  ðŸ”¥ Tip: Combo x5 or higher increases healing word chance!
  </div>
<div id="comboDisplay"></div>
<canvas id="gameCanvas"></canvas>
<div id="game-over">ðŸ’€ Game Over<br><button onclick="location.reload()">Restart</button></div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const wordList = ['fire', 'ice', 'storm', 'rune', 'portal', 'spell', 'magic', 'dark', 'light', 'burn', 'time', 'zap', 'chaos', 'nova'];
let activeWords = [];
let projectiles = [];
let powerups = [];
let currentWord = null;
let typedIndex = 0;
let gameOver = false;
let score = 0;
let level = 1;
let playerHP = 100;
let enemyHP = 100;
let wordSpeedBase = 2;
let combo = 0;
let wordsTyped = 0;
let startTime = Date.now();
let bgOffset = 0;
let enemyFlashTimer = 0;

let stars = [];
for (let i = 0; i < 100; i++) {
  stars.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, size: Math.random() * 2 });
}

class Word {
  constructor(text, x, y, speed, isHealing = false) {
    this.text = text;
    this.x = x;
    this.y = y;
    this.speed = speed;
    this.isHealing = isHealing;
  }
 draw() {
  ctx.fillStyle = this.isHealing ? 'yellow' : 'white';
  ctx.font = '26px monospace';
  ctx.fillText(this.text, this.x, this.y);
  if (currentWord === this) {
    ctx.fillStyle = this.isHealing ? '#ffff66' : 'cyan';
    ctx.shadowColor = this.isHealing ? '#ffff66' : 'cyan';
    ctx.shadowBlur = 10;
    ctx.fillText(this.text.substring(0, typedIndex), this.x, this.y);
    ctx.shadowBlur = 0;
  }
}

  update() {
    this.x -= this.speed;
    if (this.x <= 80) {
      activeWords = activeWords.filter(w => w !== this);
      playerHP -= 10 + level;
      combo = 0;
      updateComboDisplay();
      if (playerHP <= 0) endGame();
    }
  }
}


class Projectile {
  constructor(x, y, color) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.speed = 25;
    this.radius = 6;
  }
  update() {
    this.x += this.speed;
  }
  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fillStyle = this.color;
    ctx.shadowColor = this.color;
    ctx.shadowBlur = 15;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}



function spawnWord() {
  const text = wordList[Math.floor(Math.random() * wordList.length)];
  const y = canvas.height - 120;
  const x = canvas.width - 80;
  const speed = wordSpeedBase + Math.random() * 0.5;
  const isHealing = Math.random() < 0.2; // 20% chance to be a healing word
  activeWords.push(new Word(text, x, y, speed, isHealing));
}

setInterval(spawnWord, 2000);

function drawHealthBar(x, y, width, height, value, color, label) {
  ctx.fillStyle = 'gray';
  ctx.fillRect(x, y, width, height);
  ctx.fillStyle = color;
  ctx.fillRect(x, y, Math.max(0, value), height);
  ctx.fillStyle = 'white';
  ctx.font = '12px monospace';
  ctx.fillText(label, x, y - 4);
}

function updateComboDisplay() {
  const comboDisplay = document.getElementById('comboDisplay');
  if (combo > 0) {
    comboDisplay.innerText = `ðŸ”¥ Combo x${combo}`;
    comboDisplay.style.opacity = 1;
    setTimeout(() => {
      comboDisplay.style.opacity = 0;
    }, 1000);
  }
}

function updateWPM() {
  const elapsed = (Date.now() - startTime) / 60000;
  const wpm = Math.round(wordsTyped / elapsed);
  document.getElementById('wpm').innerText = wpm;
}

function drawStars() {
  ctx.fillStyle = 'black';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = 'white';
  for (let s of stars) {
    ctx.beginPath();
    ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
    ctx.fill();
    s.x -= 0.5;
    if (s.x < 0) s.x = canvas.width;
  }
}

function gameLoop() {
  if (gameOver) return;
  drawStars();

  bgOffset -= 4;
  if (bgOffset <= -40) bgOffset = 0;
  for (let i = 0; i < canvas.width / 40 + 2; i++) {
    ctx.fillStyle = '#333';
    ctx.fillRect(bgOffset + i * 40, canvas.height - 40, 40, 40);
  }

  ctx.fillStyle = enemyFlashTimer > 0 ? 'white' : 'red';
  ctx.fillRect(canvas.width - 80, canvas.height - 160, 60, 60);
  drawHealthBar(canvas.width - 140, canvas.height - 180, 100, 10, enemyHP, 'red', 'ENEMY');
  if (enemyFlashTimer > 0) enemyFlashTimer--;

  ctx.fillStyle = 'lime';
  ctx.fillRect(20, canvas.height - 160, 60, 60);
  drawHealthBar(20, canvas.height - 180, 100, 10, playerHP, 'lime', 'YOU');

  activeWords.forEach(word => {
    word.update();
    word.draw();
  });

  powerups.forEach(p => {
    p.update();
    p.draw();
  });
  powerups = powerups.filter(p => !p.collected);

  projectiles.forEach(p => {
    p.update();
    p.draw();
  });
  projectiles = projectiles.filter(p => p.x < canvas.width);

  updateWPM();
  requestAnimationFrame(gameLoop);
}

function levelUp() {
  level++;
  wordSpeedBase += 0.5;
  enemyHP = 100 + level * 5;
  document.getElementById('level').innerText = level;
}

function endGame() {
  gameOver = true;
  document.getElementById('game-over').style.display = 'block';
}

document.getElementById('powerupInfoBtn').addEventListener('click', () => {
  const infoBox = document.getElementById('powerupInfoBox');
  infoBox.style.display = infoBox.style.display === 'none' ? 'block' : 'none';
});

window.addEventListener('keydown', e => {
  if (gameOver) return;
  const key = e.key;
  if (!currentWord) {
    for (let word of activeWords) {
      if (word.text[0] === key) {
        currentWord = word;
        typedIndex = 1;
        return;
      }
    }
  } else if (currentWord.text[typedIndex] === key) {
    typedIndex++;
    const color = `hsl(${Math.random() * 360}, 100%, 50%)`;
    projectiles.push(new Projectile(80, canvas.height - 130, color));

    if (typedIndex >= currentWord.text.length) {
  activeWords = activeWords.filter(w => w !== currentWord);
  combo++;
  updateComboDisplay();
  wordsTyped++;
  let points = 1 + combo - 1;
  score += points;
  document.getElementById('score').innerText = score;
  
  if (currentWord.isHealing) {
    playerHP = Math.min(100, playerHP + 20); // heal if it's a healing word
  } else {
    enemyHP -= 10 + level;
    enemyFlashTimer = 5;
    if (enemyHP <= 0) levelUp();
  }

  currentWord = null;
  typedIndex = 0;
}

  }
});

gameLoop();
</script>
</body>
</html>