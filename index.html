<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Typing Spell Shooter - Power Mode</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(135deg, #0f0f0f, #1a1a1a);
      font-family: 'Courier New', monospace;
      color: white;
    }

    canvas {
      display: block;
    }

    #ui {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.6);
      padding: 15px 20px;
      border-radius: 12px;
      font-size: 18px;
      box-shadow: 0 0 10px lime;
    }

    .bar-label {
      font-size: 14px;
      margin-bottom: 4px;
    }

    #game-over {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2em;
      color: red;
      display: none;
      text-align: center;
    }

    #game-over button {
      margin-top: 10px;
      font-size: 1em;
      padding: 10px 20px;
      background: lime;
      border: none;
      color: black;
      cursor: pointer;
    }
  </style>
</head>
<body>
<div id="ui">
  <div>ðŸŽ¯ Score: <span id="score">0</span></div>
  <div>ðŸš€ Level: <span id="level">1</span></div>
</div>
<canvas id="gameCanvas"></canvas>
<div id="game-over">ðŸ’€ Game Over<br><button onclick="location.reload()">Restart</button></div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const wordList = ['fire', 'ice', 'storm', 'rune', 'portal', 'spell', 'magic', 'dark', 'light', 'burn', 'time', 'zap', 'chaos', 'nova'];
let activeWords = [];
let projectiles = [];
let currentWord = null;
let typedIndex = 0;
let gameOver = false;
let score = 0;
let level = 1;
let playerHP = 100;
let enemyHP = 100;
let wordSpeedBase = 1.5;

// Word class
class Word {
  constructor(text, x, y, speed) {
    this.text = text;
    this.x = x;
    this.y = y;
    this.speed = speed;
  }

  draw() {
    ctx.fillStyle = 'white';
    ctx.font = '24px monospace';
    ctx.fillText(this.text, this.x, this.y);
    if (currentWord === this) {
      ctx.fillStyle = 'lime';
      ctx.fillText(this.text.substring(0, typedIndex), this.x, this.y);
    }
  }

  update() {
    this.x -= this.speed;
    if (this.x <= 80) {
      activeWords = activeWords.filter(w => w !== this);
      playerHP -= 10;
      if (playerHP <= 0) endGame();
    }
  }
}

class Projectile {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.speed = 20;
  }

  update() {
    this.x += this.speed;
  }

  draw() {
    ctx.beginPath();
    ctx.arc(this.x, this.y, 6, 0, Math.PI * 2);
    ctx.fillStyle = 'lime';
    ctx.fill();
  }
}

function spawnWord() {
  const text = wordList[Math.floor(Math.random() * wordList.length)];
  const y = 100 + Math.random() * (canvas.height - 200);
  const x = canvas.width - 80;
  const speed = wordSpeedBase + Math.random();
  activeWords.push(new Word(text, x, y, speed));
}
setInterval(spawnWord, 2000);

function drawHealthBar(x, y, width, height, value, color, label) {
  ctx.fillStyle = 'gray';
  ctx.fillRect(x, y, width, height);
  ctx.fillStyle = color;
  ctx.fillRect(x, y, Math.max(0, value), height);
  ctx.fillStyle = 'white';
  ctx.font = '12px monospace';
  ctx.fillText(label, x, y - 4);
}

function gameLoop() {
  if (gameOver) return;
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Red enemy block
  ctx.fillStyle = 'red';
  ctx.fillRect(canvas.width - 80, canvas.height / 2 - 60, 60, 120);
  drawHealthBar(canvas.width - 140, canvas.height / 2 - 80, 100, 10, enemyHP, 'red', 'ENEMY');

  // Green player block
  ctx.fillStyle = 'green';
  ctx.fillRect(20, canvas.height / 2 - 40, 40, 80);
  drawHealthBar(20, canvas.height / 2 - 60, 100, 10, playerHP, 'lime', 'YOU');

  activeWords.forEach(word => {
    word.update();
    word.draw();
  });

  projectiles.forEach(p => {
    p.update();
    p.draw();
  });

  // Word collision is now only for visuals
  projectiles = projectiles.filter(p => p.x < canvas.width);

  requestAnimationFrame(gameLoop);
}

function levelUp() {
  level++;
  wordSpeedBase += 0.5;
  enemyHP = 100;
  document.getElementById('level').innerText = level;
}

function endGame() {
  gameOver = true;
  document.getElementById('game-over').style.display = 'block';
}

window.addEventListener('keydown', e => {
  if (gameOver) return;
  const key = e.key;

  if (!currentWord) {
    for (let word of activeWords) {
      if (word.text[0] === key) {
        currentWord = word;
        typedIndex = 1;
        return;
      }
    }
  } else if (currentWord.text[typedIndex] === key) {
    typedIndex++;
    projectiles.push(new Projectile(60, canvas.height / 2));

    if (typedIndex >= currentWord.text.length) {
      // Destroyed a word
      activeWords = activeWords.filter(w => w !== currentWord);
      enemyHP -= 10;
      score++;
      document.getElementById('score').innerText = score;
      if (enemyHP <= 0) levelUp();
      currentWord = null;
      typedIndex = 0;
    }
  }
});

gameLoop();
</script>
</body>
</html>
